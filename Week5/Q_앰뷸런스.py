# [DP] 앰뷸런스

# 앰뷸런스는 위급한 환자를 호송하는 대규모 비행선입니다. 앰뷸런스는 큰 사고가 나서 신고 접수를 받아 출동하려고 합니다.
# 신고 접수와 동시에 지도를 받는것이 원칙입니다. 이 지도는 N* M 크기이며, 위급한 환자의 수가 기록되었다고 합니다. 앰뷸런스가 이 지도를 사용해 이동할 때, 최대로 호송할 수 있는 환자 수를 출력하는 프로그램을 작성하세요.
# 앰뷸런스는 왼쪽 위(1, 1)에서 오른쪽 아래(N, M)까지 이동합니다.
# 앰뷸런스는 →, ↓, ↘ 방향으로만 움직입니다.
# 앰뷸런스는 지도 밖으로 이동하지 않습니다.

# [입력]
# 첫 번째 줄에 지도의 크기인 자연수 N과 M을 입력합니다.
# (1 ≤ N, M ≤ 100)
# 두 번째 줄부터 지점별로 환자의 수인 자연수 h_{n}를 입력합니다.
# (0 ≤ h_{n} ≤ 100)
# (예를 들어 N 번째 줄의 M 번째 수는 (N, M)에 있는 환자의 명수 입니다.)
# [출력]
# 첫 번째 줄에 앰뷸런스가 이동할 때, 최대로 호송할 수 있는 환자 수를 출력합니다.

# [입력 예시]
# 4 4
# 1 4 2 1
# 9 2 3 8
# 2 5 1 2
# 5 2 1 10
# [출력 예시]
# 35
# (1, 9, 2, 3, 8, 2, 10을 고른 경우인 35가 최대입니다.)

def ambulance(maps,n,m):

    dp = [ [0]*m for _ in range(n)]
    dp[0][0] = maps[0][0]

    for i in range(n):
        for j in range(m):
            
            up = -1
            left = -1
            if 0 <= i-1 < n : up = i-1
            if 0 <= j-1 < m : left = j-1
            
            if up != -1 and left != -1 :
                if dp[i-1][j] < dp[i][j-1] :
                    dp[i][j] = maps[i][j] + dp[i][j-1]
                else:
                    dp[i][j] = maps[i][j] + dp[i-1][j]
            elif up != -1 and left == -1:
                dp[i][j] = maps[i][j] + dp[i-1][j]
            elif up == -1 and left != -1:
                dp[i][j] = maps[i][j] + dp[i][j-1]
    
    return dp[n-1][m-1]

if __name__ == '__main__':
    n,m = map(int,input().split())
    maps = [list(map(int,input().split())) for _ in range(n)]
    
    print(ambulance(maps,n,m))


# # 아이디어
# n * m 크기 dp에서 각 원소의 값은 최적해인, (i,j) 까지 왔을 때, "가장많은 환자를 운송할 경우이다."
# 방향은 현재위치기준으로 아래,오른쪽,오른쪽아래대각선 이렇게 3가지라고 했다.
# 근데, 생각해보면, dp[i][j] 기준으로, 
# - 1. 위쪽에서부터 오는 운송자를 누적할 경우
# - 2. 왼쪽에서부터 오는 운송자를 누적할 경우
# 만, 고려해보면 된다. 왜냐면, 어떠한 경우에도, 대각선으로 바로 오는 것보다, 오른쪽->아래 or 아래->오른쪽, 2단계에 걸쳐서 오는 것이, 1사람이라도 사람을 더 실고 올 수 있는 경우이기 때문이다.

# # 결과
# 100
