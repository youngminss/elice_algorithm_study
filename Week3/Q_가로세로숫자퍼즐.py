# [BFS] 가로세로 숫자 퍼즐

# 각 칸에 0 이상 100 미만의 2개의 숫자로 이루어진 정수가 적혀있는 N * N 크기의 격자가 있습니다.
# (10 미만의 수는 빈자리를 0으로 표기합니다.)
# 퍼즐의 답은 가로 방향, 세로 방향, 대각선 방향으로 연속된 4개의 수의 곱 중 가장 큰 값입니다
# 예를 들어 5 * 5 크기의 퍼즐이 있을 때,
# 16 39 05 42 96
# 86 56 00 48 35
# 19 80 81 68 05
# 04 52 08 83 97
# 88 36 68 87 16
# 퍼즐의 답은 48 x 68 x 83 x 87 = 23,569,344이 됩니다.
# N * N 크기의 퍼즐이 주어졌을 때, 퍼즐의 답을 구하는 프로그램을 작성하세요.

# [입력]
# 첫째 줄에 숫자 퍼즐의 크기를 나타내는 자연수 N을 입력합니다.
# (4<=N<=20)
# 둘째 줄부터 N개의 줄에는 퍼즐을 구성하는 수를 공백으로 구분하여 입력합니다. 수의 범위는 0 이상 100 미만이며 10 미만의 수는 빈자리를 0으로 표기하여 두 개의 숫자로 입력됩니다.
# [출력]
# 가로, 세로, 대각선 방향으로 연속된 4개의 수의 곱 중 최댓값을 출력합니다.

# [입력 예시]
# 5
# 16 39 05 42 96
# 86 56 00 48 35
# 19 80 81 68 05
# 04 52 08 83 97
# 88 36 68 87 16
# [출력 예시]
# 23569344

def solution():

    n = int(input())
    graph = [ list(map(int,input().split()))  for _ in range(n)]

    def bfs(graph,n):

        result = 0

        for i in range(n):
            for j in range(n):
                if i+3 < n:    # 아래
                    result = max( graph[i][j]*graph[i+1][j]*graph[i+2][j]*graph[i+3][j], result)
                if j+3 < n:     # 오른쪽
                    result = max( graph[i][j]*graph[i][j+1]*graph[i][j+2]*graph[i][j+3], result)
                if i+3 < n and j+3 < n:    # 오른쪽아래 대각선
                    result = max( graph[i][j]*graph[i+1][j+1]*graph[i+2][j+2]*graph[i+3][j+3], result)
                if 3<=i<n and j+3<n:    # 오른쪽위 대각선
                    result = max( graph[i][j]*graph[i-1][j+1]*graph[i-2][j+2]*graph[i-3][j+3], result)
        
        return result 
    
    print(bfs(graph,n))


if __name__ == '__main__':
    solution()


# # 아이디어
# - 그냥 좌표평면 상의 임의의 좌표 x, y가 주어졌을 때,가로, 세로, 대각선을 모두 구해주면 되는 문제입니다.
# N의 최댓값은 20이므로 x, y 쌍의 모든 가짓수는 400개, 하나의 좌표마다 고려해야 하는 경우는 가로, 세로, 오른쪽 대각선, 왼쪽 대각선 4개이므로 4 * 400 = 1600개가 됩니다.

# 피드백
# - 일단 DFS보단, BFS로 탐색하는 것이 현명한 상황인 것을 알아야했다.
# - BFS여도, 딱히 큐를 만들어서, 방문했던 노드를 제어할 필요도 없었다.
# - 쉬운문제라고하는데, 아직 BFS,DFS 문제해결능력이 부족한것같다.