# [탐색] 함정 발동
# 8 * 8개의 방으로 이루어진 정사각형 모양의 미로가 있습니다. 이 미로에는 함정이 설치되어 있습니다.
# 함정의 위치는 가장 왼쪽 위 칸 (0, 0)부터 시작하여 한 칸씩 번갈아 모든 칸에 설치되어 있다고 합니다.

# T . T . T . T .
# . T . T . T . T
# T . T . T . T .
# . T . T . T . T
# T . T . T . T .
# . T . T . T . T
# T . T . T . T .
# . T . T . T . T   // T = 함정있는 곳

# 미로의 각 방에는 1명의 사람이 있거나 없을 수 있습니다. 사람들의 위치가 주어질 경우, 몇 명의 사람이 함정에 걸릴지 구하는 프로그램을 작성하세요.
# 단, 함정이 있는 방에 있는 사람은 항상 함정에 걸린다고 합니다.

# [입력]
# 첫째 줄부터 8개의 줄에 사람들의 위치 상태를 입력합니다. ‘.’은 빈칸이고, ‘H’는 방에 사람이 있는 상태입니다.
# [출력]
# 함정에 걸린 사람의 수를 출력합니다.

# [입력 예시]
# .H.H...H
# H...H.H.
# ...H.H.H
# H.H...H.
# .H...H..
# H...H.H.
# .H.H.H.H
# ..HH..H.
# [출력 예시]
# 1

def solution():
    maps = []
    track = ["T.T.T.T.",".T.T.T.T","T.T.T.T.",".T.T.T.T", "T.T.T.T.",".T.T.T.T", "T.T.T.T.",".T.T.T.T"]

    result = 0
    for _ in range(8):
        maps.append(input())
    for i in range(8):
        for j in range(8):
            if i % 2 == 0 :
                if j % 2 == 0 and track[i][j] == 'T' and maps[i][j] == 'H':
                    result += 1
            else:
                if j % 2 != 0 and track[i][j] == 'T' and maps[i][j] == 'H':
                    result += 1
    print(result)

if __name__ == "__main__" :
    solution()
        

# 아이디어
# - 함정지도는 이미 주어졌으니, 이를 의미하는 2차원 리스트를 만들어놓고, 비교할 8x8 사람들위치 리시트를 입력받는다.
# - 함정지도와 사람들위치지도를 비교해서, 함정을 의미하는 T와 사람이 존재한다는 H의 인덱스가(위치가)일치하면, 함정에 걸린 것임으로, 카운팅한다.

# # 결론 = 100

# # 질문
# - "탐색"문제이기도 했고, 뭔가, 머릿속에 생각나는대로 (0,0) ~ (n,n)까지 하나씩 인덱싱하면서 비교하면 시간초과가 날 줄 알았다.
# - 8x8의 작은 맵이여서 그런지 시간초과가 안나긴 했는데, 효과적인 방법이 있다면 알고싶다.
# - 문득, 생각난것은, 위에서 말한 접근법이 시간초과가 나면, "비트연산"을 이용해 볼까 했다. (대략적인 생각만 했음)
