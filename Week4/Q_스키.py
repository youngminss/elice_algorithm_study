# [DP] 스키

# 엘리스 토끼는 N * M 칸으로 이루어진 직사각형 모양의 스키장에서 스키를 타려고 합니다.
# 스키장의 각 칸에는 1 또는 0이 적혀 있으며 1이 적힌 칸을 밟으면 1점을 얻게 됩니다. 스키장은 왼쪽 위 (1, 1) 칸에서 시작하여 (N, M) 칸으로 내려오는 구조로 되어 있어 엘리스 토끼는 오른쪽 또는 아래쪽으로만 이동할 수 있습니다.
# 엘리스 토끼가 스키를 타고 내려올 때, 얻을 수 있는 최대 점수를 구하는 프로그램을 작성하세요.'

# [입력]
# 첫째 줄에 스키장의 세로 길이를 나타내는 자연수 N과 가로 길이를 나타내는 자연수 M을 입력합니다.
# (1≤N, M≤100)
# 그다음 N 행 M 열에 걸쳐 스키장에 대한 정보를 공백으로 구분되어 입력합니다.(점수는 1 또는 0입니다)
# [출력]
# 엘리스 토끼가 스키장에서 내려올 때 얻는 점수의 최댓값을 출력합니다.

# [입력 예시]
# 5 4
# 0 1 0 0
# 0 0 1 0
# 1 1 0 0
# 1 0 1 0
# 1 1 0 0
# [출력 예시]
# 4

n, m  = map(int,input().split())
arr = []
for _ in range(n):
    arr.append(list(map(int,input().split())))

dp = [[0]*m for _ in range(n)]
dp[0][0] = arr[0][0]    # 위에 처럼 dp 초기화하면, arr[0][0] = 1 이어도 dp[0][0] 은 항상 0 이된다. (주의)
for i in range(n):
    for j in range(m):
        up = i-1
        left = j-1
        if up >= 0 and left >= 0:
            dp[i][j] = max(dp[up][j],dp[i][left]) + arr[i][j]
        elif up >= 0 :
            dp[i][j] = dp[up][j] + arr[i][j]
        elif left >= 0 :
            dp[i][j] = dp[i][left] + arr[i][j]

print(dp[n-1][m-1])


# # 아이디어
# - 피드백을 받았다.
# - 1차원의 dp 문제가 아니라, 이 문제처럼, 2차원적으로도(또는 어떠한 방식으로도) DP문제가 나올 수 있다는 것을 알았다.
# - 단지, 중요한것은, 일단 이 문제에서만 보면, 포인트가 뭐냐.
# - 1. 목표는, 가장 오른쪽하단(즉,스키가 끝까지 내려왔을때)까지 왔을 때, 발생하는 "점수의 최댓값" << 최적해
# - 2. 스키는 오른쪽 또는 아래쪽으로만 이동가능하다했으니.. (i,j)번째 위치에, 나의 바로 위쪽 방향, 또는 나의 왼쪽방향으로부터 오는 점수의 더 큰값 + 자기 위치의 점수를 더한 값으로 dp를 점차 늘려가면된다.
# - 3. 시작위치인 (0,0)부터, 위에 과정을 반복해서, n * m 크기의 점수 dp를 모두 채웠을때, dp배열의 가장 오른쪽 하단 부분을 출력하면된다.

# # 결과
# 100(피드백)
