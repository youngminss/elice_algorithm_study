# [(DFS)/BFS]충치 연구

# 베이야드는 치과 연구원입니다. 어느 날 베이야드는 충치가 진행된 이빨 샘플을 받았습니다. 베이야드는 샘플을 분석하기 위해 이빨을 현미경으로 확대해 보았습니다.
# 확대해 본 결과 치아조직에 충치 조직이 존재했으며, 충치는 균에 의해 다음과 같이 진행된다고 합니다.
# 충치균이 한 마리라도 있으면 인접한 다른 치아조직으로 이동할 수 있습니다.
# 충치 조직에 인접한 치아조직은 균의 이동으로 충치 조직이 될 수 있습니다.
# (한 치아조직의 상하좌우, 네 방향에 다른 치아조직이 위치한 경우에 서로 인접해있다고 간주합니다)

# 베이야드가 충치가 진행된 조직도를 주었다고 합니다.
# 처음에 발생한 충치균 개수의 최솟값을 출력하는 프로그램을 작성하세요.

# [입력]
# 첫 번째 줄에 베이야드에게 받은 샘플을
# 가로길이 자연수 C, 세로 길이 자연수 R의 크기로 입력합니다.
# (1 ≤ C ≤ 10)
# (1 ≤ R ≤ 10)
# 공백을 간격으로 충치 조직의 개수 자연수 K를 입력합니다.
# (1 ≤ K ≤ 100)
# 그다음 줄부터는 충치 조직의 위치 자연수 X, Y를 입력합니다.
# (0 ≤ X ≤ C-1)
# (0 ≤ Y ≤ R-1)
# ※ 충치 조직은 1로, 치아조직은 0으로 입력합니다.
# [출력]
# 처음에 발생한 충치균 개수의 최솟값을 출력합니다.

# [입력 예시]
# 4 4 6
# 0 0
# 1 0
# 0 1
# 3 1
# 3 2
# 0 3
# 입력에 의한 조직도는 다음과 같습니다.
# 1 1 0 0
# 1 0 0 1
# 0 0 0 1
# 1 0 0 0
# [출력 예시]
# 3

def cavity_dfs(i,j):

    if 0<= i < c and 0<= j < r:
        if graph[i][j] == 1:
            graph[i][j] = 0
            cavity_dfs(i-1,j)
            cavity_dfs(i+1,j)
            cavity_dfs(i,j-1)
            cavity_dfs(i,j+1)
            return True
    return False
    
if __name__ == '__main__':
    c,r,k = map(int,input().split())
    graph = [[0] * r for _ in range(c)]
    for _ in range(k):
        x,y = map(int,input().split())
        graph[x][y] = 1
    
    result = 0
    for i in range(c):
        for j in range(r):
            if cavity_dfs(i,j) == True:
                result += 1
    print(result)
    

# # 아이디어
# - "섬마을지킴이공개채용" 문제와 같은 ,DFS나 BFS로 풀어도 되는 문제이다.
# - 충치조직(1)이 있는 부분을 찾고, 그 주변으로 주변, 충치가 이동할수 있는(상하좌우) 방향이 있으면, 끝까지 가면서, 처음 충치가 있던 조직을 찾아본다.
# - 충치가있는 곳들은, 반드시 연결되어 있음을 이용한다.

# # 결과
# - 100

# # 질문거리
# - 이 문제에서, 뭔가 얻어가야하는 핵심은 뭐가 있을지 ?