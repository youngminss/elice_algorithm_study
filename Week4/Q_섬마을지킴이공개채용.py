# [(DFS)/BFS]섬마을 지킴이 공개채용

# 태평양 어느 해역에는 사람들이 사는 여러 개의 섬이 있습니다.
# 그런데 나라에서는 이 섬들을 하나하나 관리하기 힘들기 때문에 범죄율이 나날이 증가했습니다.
# 그래서 이번에 섬의 치안을 담당하는 섬마을 지킴이를 채용하기로 하였습니다.
# 섬마을 지킴이는 섬의 크기와 상관없이 혼자서 하나의 섬의 치안을 담당할 수 있다고 합니다.
# 예를 들어 해역의 지도가 아래와 같이 구성되어 있으면 3명의 지킴이를 채용합니다.
# (1은 땅이고, 0은 바다입니다. 상하좌우 방향으로 연결되어 있으면 하나의 섬으로 간주하며 대각선으로 인접한 경우는 다른 섬으로 간주합니다.)

# 1 1 0 0 0 0
# 0 1 0 0 0 0
# 0 0 0 0 1 0
# 0 0 0 0 1 0
# 0 0 1 1 0 0 => 예시

# 해역의 지도가 주어졌을 때 채용할 지킴이의 수를 구하는 프로그램을 작성하세요.

# [입력]
# 첫째 줄에는 해역의 가로길이 자연수 M과 세로 길이 자연수 N, 그리고 땅의 좌표 개수 K를 입력합니다.
# (1 ≤ M, N ≤ 10)
# (1 ≤ K ≤ 100)
# 그 다음 K줄에는 땅의 좌표 (X, Y)를 입력합니다. (X, Y는 음이 아닌 정수)
# (0 ≤ X ≤ M-1)
# (0 ≤ Y ≤ N-1)

# [출력]
# 채용이 필요한 지킴이의 수를 출력합니다.
# [입력 예시]
# 6 5 7
# 0 0
# 1 0
# 1 1
# 4 2
# 4 3
# 2 4
# 3 4
# [출력 예시]
# 3

def open_recruitment_dfs(x,y):

    dx = [-1,1,0,0]
    dy = [0,0,-1,1]

    if 0<= x < m and 0<= y < n:
        if graph[x][y] == 1:
            graph[x][y] = 0
            open_recruitment_dfs(x+dx[0],y+dy[0])
            open_recruitment_dfs(x+dx[1],y+dy[1])
            open_recruitment_dfs(x+dx[2],y+dy[2])
            open_recruitment_dfs(x+dx[3],y+dy[3])
            return True
    return False

if __name__ == '__main__':
    m,n,k = map(int,input().split())
    graph = [[0] * n for _ in range(m)]
    for _ in range(k):
        x,y = map(int,input().split())
        graph[x][y] = 1

    result = 0
    for i in range(m):
            for j in range(n):
                if open_recruitment_dfs(i,j) == True :
                    result += 1
    print(result)
    

    
# # 아이디어
# - 나는 DFS로 풀었지만, 깊게는 생각안해봤는데 BFS로도 풀이가 가능할 것 같긴하다.
# - m*n 크기의 반복문을 통해서, 어떤 특정 1(즉,땅)인 곳이있으면, 그 지점으로부터, DFS를 수행해서, 1->0 (방문을 의미)으로 바꾼다.
# - 이 과정이 해당 지점에서 한번 수행하고나면, 그것과 연결된 모든, 땅은 방문을하고, 고로, 고용인원을 1명 추가하면된다.
# - m*n 번 반복하고나서, 고용인원을 출력해본다.

# # 결과
# - 100

# # 질문
# - 이 문제에서, 뭔가 얻어가야하는 핵심은 뭐가 있을지 ?
